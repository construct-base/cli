package {{.PackageName}}

import (
    "fmt"
    "math"
    "mime/multipart"

    "gorm.io/gorm"
    "base/core/types"
    "base/core/emitter"
    "base/core/storage"
    "base/core/logger"
    "base/app/models"{{if .HasTranslatableFields}}
    "base/core/translation"
    "reflect"
    "strings"{{end}}
    "{{.PackageName}}/validators"
)

const (
    Create{{.Model}}Event = "{{toLower .Plural}}.create"
    Update{{.Model}}Event = "{{toLower .Plural}}.update"
    Delete{{.Model}}Event = "{{toLower .Plural}}.delete"
)

type {{.Service}} struct {
    DB      *gorm.DB
    Emitter *emitter.Emitter
    Storage *storage.ActiveStorage
    Logger  logger.Logger{{if .HasTranslatableFields}}
    TranslationHelper *translation.Helper{{end}}
}

func New{{.Service}}(db *gorm.DB, emitter *emitter.Emitter, storage *storage.ActiveStorage, logger logger.Logger{{if .HasTranslatableFields}}, translationHelper *translation.Helper{{end}}) *{{.Service}} {
    return &{{.Service}}{
        DB:      db,
        Logger:  logger,
        Emitter: emitter,
        Storage: storage,{{if .HasTranslatableFields}}
        TranslationHelper: translationHelper,{{end}}
    }
}


// applySorting applies sorting to the query based on the sort and order parameters
func (s *{{.Service}}) applySorting(query *gorm.DB, sortBy *string, sortOrder *string) {
    // Valid sortable fields for {{.Model}}
    validSortFields := map[string]string{
        "id": "id",
        "created_at": "created_at",
        "updated_at": "updated_at",
        {{- range .Fields}}
        {{- if not .IsRelation}}
        "{{ToSnakeCase .Name}}": "{{ToSnakeCase .Name}}",
        {{- end}}
        {{- end}}
    }

    // Default sorting - if sort_order exists, always use it for custom ordering
    {{- $hasSortOrder := false }}
    {{- range .Fields}}
    {{- if eq (ToSnakeCase .Name) "sort_order"}}
    {{- $hasSortOrder = true }}
    {{- end}}
    {{- end}}
    {{- if $hasSortOrder }}
    defaultSortBy := "sort_order"
    defaultSortOrder := "asc"
    {{- else }}
    defaultSortBy := "id"
    defaultSortOrder := "desc"
    {{- end}}

    // Determine sort field
    sortField := defaultSortBy
    if sortBy != nil && *sortBy != "" {
        if field, exists := validSortFields[*sortBy]; exists {
            sortField = field
        }
    }

    // Determine sort direction (order parameter)
    sortDirection := defaultSortOrder
    if sortOrder != nil && (*sortOrder == "asc" || *sortOrder == "desc") {
        sortDirection = *sortOrder
    }

    // Apply sorting
    query.Order(sortField + " " + sortDirection)
}

func (s *{{.Model}}Service) Create(req *models.Create{{.Model}}Request) (*models.{{.Model}}, error) {
    item := &models.{{.Model}}{
        {{- range .Fields}}
        {{- if eq .Type "translation.Field" }}
        {{.Name}}: translation.NewField(req.{{.Name}}),
        {{- else if eq .Type "*storage.Attachment"}}
        // handled separately
        {{- else if eq .Relationship "belongs_to"}}
        {{- if hasSuffix .Name "Id" }}
        {{.Name}}: req.{{.Name}},
        {{- else }}
        {{.Name}}Id: req.{{.Name}}Id,
        {{- end }}
        {{- else if and .IsRelation (ne .Relationship "")}}
        {{- /* Skip all other relationship objects, only use foreign key IDs */}}
        {{- else}}
        {{- $fieldType := .Type }}
        {{- if eq .Type "text" }}{{$fieldType = "string"}}{{end}}
        {{.Name}}: req.{{.Name}},
        {{- end}}
        {{- end}}
    }

    if err := s.DB.Create(item).Error; err != nil {
        s.Logger.Error("failed to create {{toLower .Model}}", logger.String("error", err.Error()))
        return nil, err
    }

    // Emit create event
    s.Emitter.Emit(Create{{.Model}}Event, item)

    return s.GetById(item.Id)
}

func (s *{{.Model}}Service) Update(id uint, req *models.Update{{.Model}}Request) (*models.{{.Model}}, error) {
    item := &models.{{.Model}}{}
    if err := s.DB.First(item, id).Error; err != nil {
        s.Logger.Error("failed to find {{toLower .Model}} for update", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return nil, err
    }

    // Validate request
    if err := Validate{{.Model}}UpdateRequest(req, id); err != nil {
        return nil, err
    }

    // Update fields directly on the model
    {{- range .Fields}}
    
    {{- if eq .Type "*storage.Attachment" }}
    // {{.Name}} attachment is handled via separate endpoint
    {{- else if eq .Relationship "belongs_to" }}
    // For foreign key relationships
    {{- if hasSuffix .Name "Id" }}
    if req.{{.Name}} != 0 {
        item.{{.Name}} = req.{{.Name}}
    }
    {{- else }}
    if req.{{.Name}}Id != 0 {
        item.{{.Name}}Id = req.{{.Name}}Id
    }
    {{- end }}
    {{- else if not .IsRelation}}
    {{- if or (eq .Type "*bool") (eq .Type "bool")}}
    // For boolean fields, check if it's included in the request (pointer would be non-nil)
    if req.{{.Name}} != nil {
        item.{{.Name}} = *req.{{.Name}}
    }
    {{- else if hasPrefix .Type "*"}}
    {{- if or (contains .Type "int") (contains .Type "uint") (contains .Type "float")}}
    // For pointer numeric fields
    if req.{{.Name}} != nil && *req.{{.Name}} != 0 {
        item.{{.Name}} = *req.{{.Name}}
    }
    {{- else}}
    // For other pointer fields
    if req.{{.Name}} != nil {
        item.{{.Name}} = *req.{{.Name}}
    }
    {{- end}}
    {{- else if or (eq .Type "int") (eq .Type "int32") (eq .Type "int64")}}
    // For non-pointer integer fields
    if req.{{.Name}} != 0 {
        item.{{.Name}} = req.{{.Name}}
    }
    {{- else if or (eq .Type "uint") (eq .Type "uint32") (eq .Type "uint64")}}
    // For non-pointer unsigned integer fields
    if req.{{.Name}} != 0 {
        item.{{.Name}} = req.{{.Name}}
    }
    {{- else if or (eq .Type "float32") (eq .Type "float64")}}
    // For non-pointer float fields
    if req.{{.Name}} != 0 {
        item.{{.Name}} = req.{{.Name}}
    }
    {{- else if eq .Type "time.Time"}}
    // For non-pointer time.Time fields
    if !req.{{.Name}}.IsZero() {
        item.{{.Name}} = req.{{.Name}}
    }
    {{- else if eq .Type "types.DateTime"}}
    // For custom DateTime fields
    if !req.{{.Name}}.IsZero() {
        item.{{.Name}} = req.{{.Name}}
    }
    {{- else if eq .Type "translation.Field"}}
    if req.{{.Name}} != "" {
        item.{{.Name}} = translation.NewField(req.{{.Name}})
    }
    {{- else if or (eq .Type "string") (eq .Type "email")}}
    // For non-pointer string fields
    if req.{{.Name}} != "" {
        item.{{.Name}} = req.{{.Name}}
    }
    {{- else if eq .Type "text"}}
    // For non-pointer text fields
    if req.{{.Name}} != "" {
        item.{{.Name}} = req.{{.Name}}
    }
    {{- end}}
    {{- end}}
    {{- end}}

    if err := s.DB.Save(item).Error; err != nil {
        s.Logger.Error("failed to update {{toLower .Model}}", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return nil, err
    }

    // Handle many-to-many relationships
    {{- range .Fields}}
    {{- if eq .Relationship "many_to_many" }}
    if req.{{.Name}}Ids != nil {
        // Find the {{toLower .RelatedModel}}s by IDs
        var {{toLower .Name}} []*models.{{.RelatedModel}}
        if len(req.{{.Name}}Ids) > 0 {
            if err := s.DB.Where("id IN ?", req.{{.Name}}Ids).Find(&{{toLower .Name}}).Error; err != nil {
                s.Logger.Error("failed to find {{toLower .Name}} for {{toLower $.Model}} update",
                    logger.String("error", err.Error()),
                    logger.Int("id", int(id)))
                return nil, err
            }
        }

        // Replace the {{toLower .Name}} associations
        if err := s.DB.Model(item).Association("{{.Name}}").Replace({{toLower .Name}}); err != nil {
            s.Logger.Error("failed to update {{toLower $.Model}} {{toLower .Name}}",
                logger.String("error", err.Error()),
                logger.Int("id", int(id)))
            return nil, err
        }
    }
    {{- end}}
    {{- end}}

    result, err := s.GetById(item.Id)
    if err != nil {
        s.Logger.Error("failed to get updated {{toLower .Model}}", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return nil, err
    }

    // Emit update event
    s.Emitter.Emit(Update{{.Model}}Event, result)

    return result, nil
}

func (s *{{.Model}}Service) Delete(id uint) error {
    item := &models.{{.Model}}{}
    if err := s.DB.First(item, id).Error; err != nil {
        s.Logger.Error("failed to find {{toLower .Model}} for deletion", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return err
    }

    // Delete file attachments if any
    {{- range .Fields}}
    {{- if eq .Type "*storage.Attachment"}}
    if item.{{.Name}} != nil {
        if err := s.Storage.Delete(item.{{.Name}}); err != nil {
            s.Logger.Error("failed to delete {{.JSONName}}", 
                logger.String("error", err.Error()),
                logger.Int("id", int(id)))
            return err
        }
    }
    {{- end}}
    {{- end}}

    if err := s.DB.Delete(item).Error; err != nil {
        s.Logger.Error("failed to delete {{toLower .Model}}", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return err
    }

    // Emit delete event
    s.Emitter.Emit(Delete{{.Model}}Event, item)

    return nil
}



func (s *{{.Service}}) GetById(id uint) (*models.{{.Model}}, error) {
    item := &models.{{.Model}}{}
    
    query := item.Preload(s.DB)
    if err := query.First(item, id).Error; err != nil {
        s.Logger.Error("failed to get {{toLower .Model}}", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return nil, err
    }

    {{if .HasTranslatableFields}}// Load translations for all translatable fields
    if err := s.loadTranslationsForItem(item); err != nil {
        s.Logger.Error("Failed to load translations", logger.String("error", err.Error()))
        // Continue without translations rather than failing
    }{{end}}

    return item, nil
}


func (s *{{.Model}}Service) GetAll(page *int, limit *int, sortBy *string, sortOrder *string) (*types.PaginatedResponse, error) {
    var items []*models.{{.Model}}
    var total int64

    query := s.DB.Model(&models.{{.Model}}{})
    // Set default values if nil
	defaultPage := 1
	defaultLimit := 10
	if page == nil {
		page = &defaultPage
	}
	if limit == nil {
		limit = &defaultLimit
	}

    // Get total count
    if err := query.Count(&total).Error; err != nil {
        s.Logger.Error("failed to count {{toLower .Plural}}", 
            logger.String("error", err.Error()))
        return nil, err
    }

    // Apply pagination if provided
    if page != nil && limit != nil {
        offset := (*page - 1) * *limit
        query = query.Offset(offset).Limit(*limit)
    }

    // Apply sorting
    s.applySorting(query, sortBy, sortOrder)

    // Don't preload relationships for list response (faster)
    // query = (&models.{{.Model}}{}).Preload(query)

    // Execute query
    if err := query.Find(&items).Error; err != nil {
        s.Logger.Error("failed to get {{toLower .Plural}}", 
            logger.String("error", err.Error()))
        return nil, err
    }

    {{if .HasTranslatableFields}}// Load translations for all items
    if err := s.loadTranslationsForItems(items); err != nil {
        s.Logger.Error("Failed to load translations for items", logger.String("error", err.Error()))
        // Continue without translations rather than failing
    }{{end}}

    // Convert to response type
    responses := make([]*models.{{.Model}}ListResponse, len(items))
    for i, item := range items {
        responses[i] = item.ToListResponse()
    }

    // Calculate total pages
    totalPages := int(math.Ceil(float64(total) / float64(*limit)))
    if totalPages == 0 {
        totalPages = 1
    }

    return &types.PaginatedResponse{
        Data: responses,
        Pagination: types.Pagination{
            Total:      int(total),
            Page:       *page,
            PageSize:   *limit,
            TotalPages: totalPages,
        },
    }, nil
}

// GetAllForSelect gets all items for select box/dropdown options (simplified response)
func (s *{{.Model}}Service) GetAllForSelect() ([]*models.{{.Model}}, error) {
    var items []*models.{{.Model}}
    
    query := s.DB.Model(&models.{{.Model}}{})
    
    // Only select the necessary fields for select options
    {{- $nameField := "" }}
    {{- $titleField := "" }}
    {{- range .Fields }}
    {{- if not .IsRelation }}
    {{- if or (eq (toLower .Name) "name") (eq (toLower .Name) "title") }}
    {{- if eq (toLower .Name) "name" }}{{ $nameField = .Name }}{{end}}
    {{- if eq (toLower .Name) "title" }}{{ $titleField = .Name }}{{end}}
    {{- end }}
    {{- end }}
    {{- end }}
    
    {{- if or $nameField $titleField }}
    {{- if $nameField }}
    query = query.Select("id, {{ToSnakeCase $nameField}}")
    {{- else if $titleField }}
    query = query.Select("id, {{ToSnakeCase $titleField}}")
    {{- end }}
    {{- else }}
    query = query.Select("id") // Only ID if no name/title field found
    {{- end }}
    
    // Order by name/title for better UX
    {{- if $nameField }}
    query = query.Order("{{ToSnakeCase $nameField}} ASC")
    {{- else if $titleField }}
    query = query.Order("{{ToSnakeCase $titleField}} ASC")
    {{- else }}
    query = query.Order("id ASC")
    {{- end }}
    
    if err := query.Find(&items).Error; err != nil {
        s.Logger.Error("Failed to fetch items for select", logger.String("error", err.Error()))
        return nil, err
    }
    
    {{if .HasTranslatableFields}}// Load translations for all items
    if err := s.loadTranslationsForItems(items); err != nil {
        s.Logger.Error("Failed to load translations for items", logger.String("error", err.Error()))
        // Continue without translations rather than failing
    }{{end}}
    
    return items, nil
}

{{- /* Add translation loading helper methods */}}
{{- if .HasTranslatableFields }}

// loadTranslationsForItem loads translations for all translatable fields in a single item
func (s *{{.Service}}) loadTranslationsForItem(item *models.{{.Model}}) error {
    if item == nil {
        return nil
    }
    
    modelName := item.GetModelName()
    modelId := item.GetId()
    
    // Load translations for each translatable field
    {{- range .Fields}}
    {{- if eq .Type "translation.Field" }}
    if err := s.TranslationHelper.Service.LoadTranslationsForField(&item.{{.Name}}, modelName, modelId, "{{ToSnakeCase .Name}}"); err != nil {
        s.Logger.Error("Failed to load translations for {{.Name}}", logger.String("error", err.Error()))
        // Don't fail the request, just log the error
    }
    {{- end }}
    {{- end}}
    
    return nil
}

// loadTranslationsForItems loads translations for all translatable fields in multiple items
func (s *{{.Service}}) loadTranslationsForItems(items []*models.{{.Model}}) error {
    for _, item := range items {
        if err := s.loadTranslationsForItem(item); err != nil {
            return err
        }
    }
    return nil
}
{{- end }}

{{- range .Fields}}
{{- if eq .Type "*storage.Attachment"}}
// Upload{{.Name}} uploads a file for the {{$.Model}}'s {{.Name}} field
func (s *{{$.Model}}Service) Upload{{.Name}}(id uint, file *multipart.FileHeader) (*models.{{$.Model}}, error) {
    item := &models.{{$.Model}}{}
    if err := s.DB.First(item, id).Error; err != nil {
        s.Logger.Error("failed to find {{toLower $.Model}}", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return nil, err
    }

    // Delete existing file if any
    if item.{{.Name}} != nil {
        if err := s.Storage.Delete(item.{{.Name}}); err != nil {
            s.Logger.Error("failed to delete existing {{.JSONName}}", 
                logger.String("error", err.Error()),
                logger.Int("id", int(id)))
            return nil, err
        }
    }

    // Attach new file
    attachment, err := s.Storage.Attach(item, "{{.JSONName}}", file)
    if err != nil {
        s.Logger.Error("failed to attach {{.JSONName}}", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return nil, err
    }

    // Update the model with the new attachment
    if err := s.DB.Model(item).Association("{{.Name}}").Replace(attachment); err != nil {
        s.Logger.Error("failed to associate {{.JSONName}}", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return nil, err
    }

    return s.GetById(id)
}

// Remove{{.Name}} removes the file from the {{$.Model}}'s {{.Name}} field
func (s *{{$.Model}}Service) Remove{{.Name}}(id uint) (*models.{{$.Model}}, error) {
    item := &models.{{$.Model}}{}
    if err := s.DB.First(item, id).Error; err != nil {
        s.Logger.Error("failed to find {{toLower $.Model}}", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return nil, err
    }

    if item.{{.Name}} == nil {
        return item, nil
    }

    if err := s.Storage.Delete(item.{{.Name}}); err != nil {
        s.Logger.Error("failed to delete {{.JSONName}}", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return nil, err
    }

    // Clear the association
    if err := s.DB.Model(item).Association("{{.Name}}").Clear(); err != nil {
        s.Logger.Error("failed to clear {{.JSONName}} association", 
            logger.String("error", err.Error()),
            logger.Int("id", int(id)))
        return nil, err
    }

    return s.GetById(id)
}
{{- end}}
{{- end}}
